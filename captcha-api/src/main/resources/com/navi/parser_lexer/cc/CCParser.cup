package com.navi.captchaapi.parser_lexer.cc;
import java_cup.runtime.*;
import java.util.*;
import java.text.DecimalFormat;
import com.navi.captchaapi.parser_lexer.*;
import com.navi.captchaapi.parser_lexer.cc.obj.*;
import com.navi.captchaapi.parser_lexer.cc.obj.node.*;

parser code
{:

    public Label label = new Label();
    public Program program = new Program(new Location(0,0), new ArrayList<>());
    public ArrayList<String> staticVariables = new ArrayList<>();

    boolean hasHref, hasBackground, hasColor, hasFontSize, hasFontFamily, hasTextAlign, hasType, hasId, hasName, hasCols, hasRows, hasClass, hasSrc, hasWidth, hasHeight, hasAlt, hasOnclick;

    public void resetBooleans(){
        hasHref = false;
        hasBackground = false;
        hasColor = false;
        hasFontSize = false;
        hasFontFamily = false;
        hasTextAlign = false;
        hasType = false;
        hasId = false;
        hasName = false;
        hasCols = false;
        hasRows = false;
        hasClass = false;
        hasSrc = false;
        hasWidth = false;
        hasHeight = false;
        hasAlt = false;
        hasOnclick = false;
    }
    public boolean validateCC(){
        boolean possibleCondition = hasId || hasName;
        boolean other = !(hasHref || hasBackground || hasColor || hasFontSize || hasFontFamily ||
                hasTextAlign || hasType || hasCols || hasRows ||
                hasClass || hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);

        return (possibleCondition && other) || allFalse();
    }
    public boolean validateBody(){
      boolean possibleCondition = hasBackground;
      boolean other = !(hasHref || hasColor || hasFontSize || hasFontFamily ||
              hasTextAlign || hasType || hasId || hasName || hasCols || hasRows ||
              hasClass || hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);

      return (possibleCondition && other) || allFalse();
    }
    public boolean validateLink(){
      boolean possibleCondition = hasHref;
      boolean other = !(hasBackground || hasColor || hasFontSize || hasFontFamily ||
              hasTextAlign || hasType || hasId || hasName || hasCols || hasRows ||
              hasClass || hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);

      return (possibleCondition && other) || allFalse();
    }
    public boolean validateSpanSelectH1P(){
      boolean possibleCondition = hasColor || hasFontFamily || hasFontSize || hasTextAlign || hasId;
      boolean other = !(hasHref || hasBackground ||
              hasType || hasName || hasCols || hasRows ||
              hasClass || hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);

      return (possibleCondition && other) || allFalse();
    }
    public boolean validateInput(){
      boolean possibleCondition = hasColor || hasFontFamily || hasFontSize || hasTextAlign || hasId || hasType;
      boolean other = !(hasHref || hasBackground ||
              hasName || hasCols || hasRows ||
              hasClass || hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);

      return (possibleCondition && other) || allFalse();
    }
    public boolean validateTextArea(){
      boolean possibleCondition = hasFontFamily || hasFontSize || hasTextAlign || hasId || hasCols || hasRows;
      boolean other = !(hasHref || hasBackground || hasColor ||
              hasType || hasName ||
              hasClass || hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);

      return (possibleCondition && other) || allFalse();
    }
    public boolean validateDiv(){
      boolean possibleCondition = hasBackground || hasFontFamily || hasFontSize || hasTextAlign || hasId || hasClass || hasColor;
      boolean other = !(hasHref ||
              hasType || hasName || hasCols || hasRows ||
              hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);

      return (possibleCondition && other) || allFalse();
    }
    public boolean validateImg(){
      boolean possibleCondition = hasSrc || hasWidth || hasHeight || hasAlt || hasId;
      boolean other = !(hasHref || hasBackground || hasColor || hasFontSize || hasFontFamily ||
              hasTextAlign || hasType || hasName || hasCols || hasRows ||
              hasClass || hasOnclick);

      return (possibleCondition && other) || allFalse();
    }
    public boolean validateButton(){
      boolean possibleCondition = hasFontSize || hasFontFamily || hasTextAlign || hasId || hasColor || hasBackground || hasOnclick;
      boolean other = !(hasHref ||
              hasType || hasName || hasCols || hasRows ||
              hasClass || hasSrc || hasWidth || hasHeight || hasAlt);

      return (possibleCondition && other) || allFalse();
    }
    private boolean allFalse(){
        return !(hasHref || hasBackground || hasColor || hasFontSize || hasFontFamily ||
                hasTextAlign || hasType || hasId || hasName || hasCols || hasRows ||
              hasClass || hasSrc || hasWidth || hasHeight || hasAlt || hasOnclick);
    }
    public CCParser(CCLexer lex) {
        super(lex);
        //resetBooleans();
    }
    //Metodo al que se llama ante algun error sintactico
    public void syntax_error(Symbol s){
        String lexeme = "";
        if(s.value != null) lexeme = s.value.toString();
        int line = s.left;
        int col = s.right;
        System.out.println("ERROR SINTÁCTICO RECUPERADO");
        System.out.println("\tLexeme: " + lexeme);
        System.out.println("\trow: " + line);
        System.out.println("\tcol: " + col);
        HashMap<String, String> symbolNames = Validate.getSymbolNames();
        List<Integer> tokens = expected_token_ids();
        String des = "Se esperaba: ";
        for(Integer i : tokens) {
            String fromId = symbl_name_from_id(i);
            String symbolName = symbolNames.get(fromId);
            if(symbolName != null){
                des += "'"+symbolName+ "' o ";
            }
            else{
                if(!fromId.equals("error") && !fromId.equals("EOF")){
                    des += fromId +" o ";
                }
            }
        }
        if(des.length() > 3) des = des.substring(0, des.length() - 3);
        addError(lexeme, line, col, des);
    }

    //Metodo que se llama en el momento en que ya no es posible una recuperacion
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        String lexeme = "";
        if(s.value != null) lexeme = s.value.toString();
        int line = s.left;
        int col = s.right;
        System.out.println("ERROR SINTACTICO NO RECUPERABLE");
        System.out.println("\tLexeme: " + lexeme);
        System.out.println("\trow: " + line);
        System.out.println("\tcol: " + col);
        HashMap<String, String> symbolNames = Validate.getSymbolNames();
        List<Integer> tokens = expected_token_ids();
        String des = "Se esperaba: ";
        for(Integer i : tokens) {
            String fromId = symbl_name_from_id(i);
            String symbolName = symbolNames.get(fromId);
            if(symbolName != null){
                des += "'"+symbolName+ "' o ";
            }
            else{
                if(!fromId.equals("error") && !fromId.equals("EOF")){
                    des += fromId +" o ";
                }
            }
        }
        if(des.length() > 3) des = des.substring(0, des.length() - 3);
        addError(lexeme, line, col, des);
    }

    private void addError(String lexeme, int line, int col, String description){
        ErrorsLP.addError(lexeme, line, col, "Error Sintáctico", description);
    }

    private void addParameterError(String type, int line, int col){
        ErrorsLP.addError(type, line, col, "Semántico", "Parametro " + type + " duplicado");
    }
    private void addPError(String type, int line, int col){
        ErrorsLP.addError(type, line, col, "Semántico", "Parametro " + type + " no esperado");
    }
    protected int error_sync_size() {
            return 1;
    }
:}

terminal C_CC, C_HEAD, C_TITLE, C_LINK, C_BODY, C_SPAM, C_INPUT, C_TEXTAREA, C_SELECT, C_OPTION,
        C_DIV, C_IMG, C_BR, C_BUTTON, C_H1, C_P, C_SCRIPTING,
        HREF, BACKGROUND, COLOR, FONT_SIZE, FONT_FAMILY, TEXT_ALIGN, TYPE, ID, NAME, COLS, ROWS,
        CLASS, SRC, WIDTH, HEIGHT, ALT, ONCLICK,
        INTEGER, DECIMAL, BOOLEAN, CHAR, STRING,
        INIT, END, IF, THEN, ELSE, REPEAT, HUNTIL, WHILE, THENWHILE, TRUE, FALSE,
        LT, GT

        ;

terminal String STRING_LITERAL, SIMPLE_STRING, NUMBER, CHAR_LITERAL,
                EQUAL, IDENTIFIER, TEXT, FUNCTION_ID,
                INSERT, ON_LOAD, GET_ELEMENT_BY_ID, GLOBAL,
                ASC, DESC, LETPAR_NUM, LETIMPAR_NUM, REVERSE, CARACTER_ALEATORIO, NUM_ALEATORIO,
                ALERT_INFO, EXIT, REDIRECT,
                PLUS, MINUS, TIMES, SLASH, LPAREN, RPAREN,
                COLON, SEMICOLON, COMMA, VERTICAL_BAR,
                REL_OP, OR, AND, NOT, LBRACKET, RBRACKET, LBRACE, RBRACE
                ;

non terminal s;
non terminal Label cc;
non terminal ArrayList<Parameter> open_cc, open_head, open_body, open_title, open_link, open_spam, open_input, open_textarea, open_select, open_option, open_div, open_img, open_br, open_button, open_h1, open_p, open_scripting;
non terminal close_cc, close_head, close_body, close_title, close_link, close_spam, close_input, close_textarea, close_select, close_option, close_div, close_img, close_button, close_h1, close_p, close_scripting;
non terminal Label c_head, c_body, c_title, c_link, c_spam, c_input, c_textarea, c_select, c_option, c_div, c_img, c_br, c_button, c_h1, c_p, c_scripting;
non terminal ArrayList<Object> head_labels, c_cc_body, body_labels;
non terminal Object body_label;

non terminal ArrayList<Parameter> parameters_opt, parameters;
non terminal Parameter parameter;
non terminal Parameter href, background, color, font_size, font_family, text_align, type, id, name, cols, rows, clase, src, width, height, alt, onclick;

non terminal List<Identifier> listIds;
non terminal Identifier variable_id;

non terminal List<FunctionDeclaration> global_stmt_opt;
non terminal List<FunctionDeclaration> global_stmt;
non terminal List<VariableDeclarator> variable_declarators;
non terminal List<VariableDeclarator> variable_declarator;
non terminal List<Assignment> variable_assignment_declarator;
non terminal Assignment variable_assignment;
non terminal Type variable_type;

non terminal FunctionDeclaration method_declarator;
non terminal List<Node> method_block;
non terminal init_block, end_block;
non terminal List<Node> block;
non terminal List<Node> block_stmt;
non terminal List<Node> block_opt;
non terminal List<Node> body_block_opt;
non terminal List<Node> body_block;
non terminal List<Node> body_stmt;


non terminal CallFunction function_call_stmt;
non terminal CallFunction function_call_return;
non terminal List<Expr> param, params;
non terminal IfStmt if_stmt;
non terminal List<Node> else_stmt;
non terminal List<IfStmt> else_if_stmts;
non terminal IfStmt else_if_stmt;
non terminal ForStmt for_stmt;
non terminal VariableDeclarator init_for;
non terminal WhileStmt while_stmt;

non terminal Expr expression;
non terminal Expr conditional_expression;
non terminal Expr conditional_or_expression;
non terminal Expr conditional_and_expression;
non terminal Expr relational_expression;
non terminal Expr additive_expression;
non terminal Expr multiplicative_expression;
non terminal UnaryExpression unary_expression;
non terminal UnaryExpression value_literal;
non terminal String string_literal;
non terminal String char_literal;
non terminal String simple_string;

non terminal String text;
non terminal String string_text;



start with s;

s ::= cc:c
    {:
    label = c;
    :}
    | body_label:l
    {:
    label = (Label) l;
    :}
    ;
/* Open labels */
open_cc         ::= LT C_CC parameters_opt:p GT             {: RESULT = p; :};
open_head       ::= LT C_HEAD GT                            {: RESULT = new ArrayList<>(); :};
open_body       ::= LT C_BODY parameters_opt:p GT           {: RESULT = p; :};
open_title      ::= LT C_TITLE GT                           {: RESULT = new ArrayList<>(); :};
open_link       ::= LT C_LINK parameters_opt:p GT           {: RESULT = p; :};
open_spam       ::= LT C_SPAM parameters_opt:p GT           {: RESULT = p; :};
open_input      ::= LT C_INPUT parameters_opt:p GT          {: RESULT = p; :};
open_textarea   ::= LT C_TEXTAREA parameters_opt:p C_CC GT  {: RESULT = p; :};
open_select     ::= LT C_SELECT parameters_opt:p GT         {: RESULT = p; :};
open_option     ::= LT C_OPTION parameters_opt:p GT         {: RESULT = p; :};
open_div        ::= LT C_DIV parameters_opt:p GT            {: RESULT = p; :};
open_img        ::= LT C_IMG parameters_opt:p GT            {: RESULT = p; :};
open_br         ::= LT C_BR GT                              {: RESULT = new ArrayList<>(); :};
open_button     ::= LT C_BUTTON parameters_opt:p GT         {: RESULT = p; :};
open_h1         ::= LT C_H1 parameters_opt:p GT             {: RESULT = p; :};
open_p          ::= LT C_P parameters_opt:p GT              {: RESULT = p; :};
open_scripting  ::= LT C_SCRIPTING GT                       {: RESULT = new ArrayList<>(); :};
/* Close labels */
close_cc        ::= LT SLASH C_CC GT;
close_head      ::= LT SLASH C_HEAD GT;
close_body      ::= LT SLASH C_BODY GT;
close_title     ::= LT SLASH C_TITLE GT;
close_link      ::= LT SLASH C_LINK GT;
close_spam      ::= LT SLASH C_SPAM GT;
close_input     ::= LT SLASH C_INPUT GT;
close_textarea  ::= LT SLASH C_TEXTAREA GT;
close_select    ::= LT SLASH C_SELECT GT;
close_option    ::= LT SLASH C_OPTION GT;
close_div       ::= LT SLASH C_DIV GT;
close_img       ::= LT SLASH C_IMG GT;
close_button    ::= LT SLASH C_BUTTON GT;
close_h1        ::= LT SLASH C_H1 GT;
close_p         ::= LT SLASH C_P GT;
close_scripting ::= LT SLASH C_SCRIPTING GT;
/* Labels */
cc ::= open_cc:p c_cc_body:l close_cc
        {:
        RESULT = new Label(pleft, pright, Label.HTML, p, l);
        :}
        ;

c_cc_body ::= c_head:h c_body:b
            {:
            var labels = new ArrayList<Object>();
            labels.add(h);
            labels.add(b);
            RESULT = labels;
            :}
            ;

c_head ::= open_head:p head_labels:l close_head
            {:
            RESULT = new Label(pleft, pright, Label.HEAD, l);
            :}
            |open_head:p close_head
            {:
            RESULT = new Label(pleft, pright, Label.HEAD);
            :}
            ;


c_title ::= open_title:p string_text:t close_title
            {:
            var text = new ArrayList<Object>();
            text.add(t);
            RESULT = new Label(pleft, pright, Label.TITLE, text);
            :}
            ;
c_link ::= open_link:p close_link
            {:
            RESULT = new Label(pleft, pright, Label.LINK, p, new ArrayList<>());
            :}
            ;

head_labels ::= c_title:t c_link:l
                {:
                var labels = new ArrayList<Object>();
                labels.add(t);
                labels.add(l);
                RESULT = labels;
                :}
                | c_link:l c_title:t
                {:
                var labels = new ArrayList<Object>();
                labels.add(l);
                labels.add(t);
                RESULT = labels;
                :}
                ;

c_body ::= open_body:p body_labels:l close_body
        {:
        RESULT = new Label(pleft, pright, Label.BODY, l);
        :}
        | open_body:p close_body
        {:
        RESULT = new Label(pleft, pright, Label.BODY);
        :}
        ;
c_spam ::= open_spam:p body_labels:l close_spam
        {:
        RESULT = new Label(pleft, pright, Label.SPAN, p, l);
        :}
        | open_spam:p close_spam
        {:
        RESULT = new Label(pleft, pright, Label.SPAN, p, new ArrayList<>());
        :}
        ;
c_input ::= open_input:p body_labels:l close_input
        {:
        RESULT = new Label(pleft, pright, Label.INPUT, p, l);
        :}
        | open_input:p close_input
        {:
        RESULT = new Label(pleft, pright, Label.INPUT, p, new ArrayList<>());
        :}
        ;
c_textarea ::= open_textarea:p body_labels:l close_textarea
        {:
        RESULT = new Label(pleft, pright, Label.TEXTAREA, p, l);
        :}
        | open_textarea:p close_textarea
        {:
        RESULT = new Label(pleft, pright, Label.TEXTAREA, p, new ArrayList<>());
        :}
        ;
c_select ::= open_select:p body_labels:l close_select
        {:
        RESULT = new Label(pleft, pright, Label.SELECT, p, l);
        :}
        | open_select:p close_select
        {:
        RESULT = new Label(pleft, pright, Label.SELECT, p, new ArrayList<>());
        :}
        ;
c_option ::= open_option:p body_labels:l close_option
        {:
        RESULT = new Label(pleft, pright, Label.OPTION, p, l);
        :}
        | open_option:p close_option
        {:
        RESULT = new Label(pleft, pright, Label.OPTION, p, new ArrayList<>());
        :}
        ;
c_div ::= open_div:p body_labels:l close_div
        {:
        RESULT = new Label(pleft, pright, Label.DIV, p, l);
        :}
        | open_div:p close_div
        {:
        RESULT = new Label(pleft, pright, Label.DIV, p, new ArrayList<>());
        :}
        ;
c_img ::= open_img:p body_labels:l close_img
        {:
        RESULT = new Label(pleft, pright, Label.IMG, p, l);
        :}
        | open_img:p close_img
        {:
        RESULT = new Label(pleft, pright, Label.IMG, p, new ArrayList<>());
        :}
        ;
c_br ::= open_br:p
        {:
        RESULT = new Label(pleft, pright, Label.BR);
        :}
        ;
c_button ::= open_button:p body_labels:l close_button
        {:
        RESULT = new Label(pleft, pright, Label.BUTTON, p, l);
        :}
        | open_button:p close_button
        {:
        RESULT = new Label(pleft, pright, Label.BUTTON, p, new ArrayList<>());
        :}
        ;
c_h1 ::= open_h1:p body_labels:l close_h1
        {:
        RESULT = new Label(pleft, pright, Label.H1, p, l);
        :}
        | open_h1:p close_h1
        {:
        RESULT = new Label(pleft, pright, Label.H1, p, new ArrayList<>());
        :}
        ;
c_p ::= open_p:p body_labels:l close_p
        {:
        RESULT = new Label(pleft, pright, Label.P, p, l);
        :}
        | open_p:p close_p
        {:
        RESULT = new Label(pleft, pright, Label.P, p, new ArrayList<>());
        :}
        ;
c_scripting ::= open_scripting global_stmt_opt close_scripting
        {:
        //RESULT = new Label(pleft, pright, Label.SCRIPTING, p, l);
        :}
        ;


body_labels ::= body_label:l
            {:
            var labels = new ArrayList<Object>();
            labels.add(l);
            RESULT = labels;
            :}
            | body_labels:ls body_label:l
            {:
            ls.add(l);
            RESULT = ls;
            :}
            ;

body_label ::= c_spam:l
                {:
                RESULT = l;
                :}
                | c_input:l
                 {:
                 RESULT = l;
                 :}
                | c_textarea:l
                {:
                RESULT = l;
                :}
                | c_select:l
                {:
                RESULT = l;
                :}
                | c_option:l
                {:
                RESULT = l;
                :}
                | c_div:l
                {:
                RESULT = l;
                :}
                | c_img:l
                {:
                RESULT = l;
                :}
                | c_br:l
                {:
                RESULT = l;
                :}
                | c_button:l
                {:
                RESULT = l;
                :}
                | c_h1:l
                {:
                RESULT = l;
                :}
                | c_p:l
                {:
                RESULT = l;
                :}
                | c_scripting:l
                {:
                RESULT = l;
                :}
                | text:t
                {:
                RESULT = t;
                :}
                | error
                ;



parameters_opt ::=
                {:
                RESULT = new ArrayList<>();
                :}
                | parameters:ps
                {:
                RESULT = ps;
                :}
                ;

parameters ::= parameter:p
            {:
            var parameters = new ArrayList<Parameter>();
            parameters.add(p);
            RESULT = parameters;
            :}
            | parameters:ps parameter:p
            {:
            ps.add(p);
            RESULT = ps;
            :}
            ;

parameter ::= href:p
            {:
            if(!hasHref) hasHref = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | background:p
            {:
            if(!hasBackground) hasBackground = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | color:p
            {:
            if(!hasColor) hasColor = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | font_size:p
            {:
            if(!hasFontSize) hasFontSize = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | font_family:p
            {:
            if(!hasFontFamily) hasFontFamily = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | text_align:p
            {:
            if(!hasTextAlign) hasTextAlign = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | type:p
            {:
            if(!hasType) hasType = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | id:p
            {:
            if(!hasId) hasId = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | name:p
            {:
            if(!hasName) hasName = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | cols:p
            {:
            if(!hasCols) hasCols = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | rows:p
            {:
            if(!hasRows) hasRows = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | clase:p
            {:
            if(!hasClass) hasClass = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | src:p
            {:
            if(!hasSrc) hasSrc = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | width:p
            {:
            if(!hasWidth) hasWidth = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | height:p
            {:
            if(!hasHeight) hasHeight = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | alt:p
            {:
            if(!hasAlt) hasAlt = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            | onclick:p
            {:
            if(!hasOnclick) hasOnclick = true;
            else addParameterError(p.getTypeStr(), pleft, pright);
            RESULT = p;
            :}
            ;

href ::= LBRACKET HREF EQUAL string_literal:s RBRACKET
        {: staticVariables.add("let url = '" + s + "'");
        RESULT = new Parameter(sleft, sright, Parameter.HREF, s); :};

background ::= LBRACKET BACKGROUND EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.BACKGROUND, s); :};

color ::= LBRACKET COLOR EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.COLOR, s); :}
        ;

font_size ::= LBRACKET FONT_SIZE EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.FONT_SIZE, s); :};

font_family ::= LBRACKET FONT_FAMILY EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.FONT_FAMILY, s); :};

text_align ::= LBRACKET TEXT_ALIGN EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.TEXT_ALIGN, s); :}
        ;

type ::= LBRACKET TYPE EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.TYPE, s); :}
        ;

id ::= LBRACKET ID EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.ID, s); :};

name ::= LBRACKET NAME EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.NAME, s); :}
        ;

cols ::= LBRACKET COLS EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.COLS, s); :}
        ;

rows ::= LBRACKET ROWS EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.ROWS, s); :}
        ;

clase ::= LBRACKET CLASS EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.CLASS, s); :}
        ;

src ::= LBRACKET SRC EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.SRC, s); :}
        ;

width ::= LBRACKET WIDTH EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.WIDTH, s); :}
        ;

height ::= LBRACKET HEIGHT EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.HEIGHT, s); :}
        ;

alt ::= LBRACKET ALT EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.ALT, s); :}
        ;

onclick ::= LBRACKET ONCLICK EQUAL string_literal:s RBRACKET
        {: RESULT = new Parameter(sleft, sright, Parameter.ONCLICK, s); :}
        ;


/* SCRIPTING LABEL BODY */

global_stmt_opt ::=
                | global_stmt:g
                {:
                program.getBody().addAll(g);
                RESULT = g;
                :}
                ;

global_stmt ::= method_declarator:f
                {:RESULT = new ArrayList<>(Arrays.asList(f)); :}
                | global_stmt:g method_declarator:f
                {:
                g.add(f);
                RESULT = g;
                :}
                ;

variable_declarators ::= variable_type:t GLOBAL variable_declarator:vs
                        {:
                        for(VariableDeclarator v: vs){
                            v.setType(t);
                            v.setGlobal(true);
                            staticVariables.add("let "+v.getText());
                            v.setText("");
                        }
                        RESULT = vs;
                        :}
                        | variable_type:t variable_declarator:vs
                        {:
                        for(VariableDeclarator v: vs){
                            v.setType(t);
                            v.setText("let "+v.getText());
                        }
                        RESULT = vs;
                        :}
                        ;

variable_declarator ::= variable_id:s
                    {:RESULT = new ArrayList<>(Arrays.asList(new VariableDeclarator(new Location(sleft, sright), s, null))); :}
                    | variable_assignment_declarator:s
                    {:
                    ArrayList<VariableDeclarator> v = new ArrayList<>();
                    for(Assignment a: s){
                        v.add(new VariableDeclarator(a.getLoc(), a.getId(), a.getExpression()));
                    }
                    RESULT = v;
                    :}
                    ;

listIds ::= variable_id:i
            {:RESULT = new ArrayList<>(Arrays.asList(i)); :}
            | listIds:ids COMMA variable_id:i
            {:
            ids.add(i);
            RESULT = ids;
            :}
            ;

variable_id ::= IDENTIFIER:i {:RESULT = new Identifier(new Location(ileft, iright), i); :};

variable_assignment_declarator ::= listIds:i EQUAL expression:e
                               {:
                               ArrayList<Assignment> as = new ArrayList<>();
                               for(Identifier id: i){
                                   as.add(new Assignment(id.getLoc(), id, e));
                               }
                               RESULT = as;
                               :}
                               ;

variable_assignment ::= variable_id:i EQUAL expression:e
                    {:RESULT = new Assignment(new Location(ileft, iright), i, e); :}
                    ;

variable_type ::= INTEGER   {:RESULT = Type.INT;:}
                | STRING    {:RESULT = Type.STRING;:}
                | DECIMAL   {:RESULT = Type.DECIMAL;:}
                | CHAR      {:RESULT = Type.CHAR;:}
                | BOOLEAN   {:RESULT = Type.BOOLEAN;:}
                ;

method_declarator ::= FUNCTION_ID:f LPAREN RPAREN method_block:b
                    {:RESULT = new FunctionDeclaration(new Location(fleft, fright), f, new ArrayList<>(), Type.VOID, b); :}
                    | ON_LOAD:f LPAREN RPAREN method_block:b
                    {:RESULT = new FunctionDeclaration(new Location(fleft, fright), f, new ArrayList<>(), Type.VOID, b); :}
                    ;

method_block ::= LBRACKET body_block_opt:b RBRACKET
                {:RESULT = b; :}
                ;

body_block_opt ::= {:RESULT = new ArrayList<>(); :}
                | body_block:b
                {:RESULT = b; :}
                ;

body_block ::= body_stmt:b
                {:RESULT = b; :}
                | body_block:bb body_stmt:b
                {:
                bb.addAll(b);
                RESULT = bb; :}
                ;

body_stmt ::= variable_declarators:b SEMICOLON
            {:
            b.forEach(v->{
              if(v.isGlobal()) v.setText("");
              else v.setText(v.getText()+";");
            });
            List<Node> c = new ArrayList<>();
            c.addAll(b);
            RESULT = c;  :}
            | variable_assignment:b SEMICOLON
            {: b.setText(b.getText()+";");
            RESULT = new ArrayList<>(Arrays.asList(b)); :}
            | function_call_stmt:b SEMICOLON
            {: b.setText(b.getText()+";");
            RESULT = new ArrayList<>(Arrays.asList(b)); :}
            | if_stmt:b
            {:RESULT = new ArrayList<>(Arrays.asList(b)); :}
            | for_stmt:b
            {:RESULT = new ArrayList<>(Arrays.asList(b)); :}
            | while_stmt:b
            {:RESULT = new ArrayList<>(Arrays.asList(b)); :}
            | error
            ;

function_call_stmt ::= ALERT_INFO:f LPAREN expression:p RPAREN
                    {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>(Arrays.asList(p)));:}
                    | EXIT:f LPAREN RPAREN
                    {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>());:}
                    | REDIRECT:f LPAREN RPAREN
                    {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>());:}
                    | INSERT:f LPAREN params:p RPAREN
                    {:RESULT = new CallFunction(new Location(fleft, fright), f, p);:}
                    ;

function_call_return ::= ASC:f LPAREN expression:p RPAREN
                        {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>(Arrays.asList(p)));:}
                        | DESC:f LPAREN expression:p RPAREN
                        {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>(Arrays.asList(p)));:}
                        | LETPAR_NUM:f LPAREN expression:p RPAREN
                        {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>(Arrays.asList(p)));:}
                        | LETIMPAR_NUM:f LPAREN expression:p RPAREN
                        {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>(Arrays.asList(p)));:}
                        | REVERSE LPAREN:f expression:p RPAREN
                        {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>(Arrays.asList(p)));:}
                        | CARACTER_ALEATORIO:f LPAREN RPAREN
                        {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>());:}
                        | NUM_ALEATORIO:f LPAREN RPAREN
                        {:RESULT = new CallFunction(new Location(fleft, fright), f, new ArrayList<>());:}
                        | GET_ELEMENT_BY_ID:f LPAREN param:p RPAREN
                        {:
                        var xd = new CallFunction(new Location(fleft, fright), "document.getElementById", p);
                        xd.setText(xd.getText() + ".value");
                        RESULT = xd;
                        :}
                        ;


params ::= param:p
        {:RESULT = p; :}
        | params:ps COMMA param:p
        {:
        ps.addAll(p);
        RESULT = ps;:}
        ;

param ::= variable_id:v
        {:RESULT = new ArrayList<>(Arrays.asList(new UnaryExpression(new Location(vleft, vright), v.getText(), Type.STRING, null, v))); :}
        | simple_string:v
        {:RESULT = new ArrayList<>(Arrays.asList(new UnaryExpression(new Location(vleft, vright), "'"+v+"'", Type.STRING, null, v))); :}
        ;

init_block ::= INIT LBRACE COLON
            ;

end_block ::= COLON RBRACE END
            ;

block_opt ::= init_block body_block_opt:b end_block
        {:RESULT = b; :}
        ;

block ::= block_opt:b
        {:RESULT = b; :}
        | block_stmt:b
        {:RESULT = b; :}
        ;

block_stmt ::= variable_declarators:v SEMICOLON
            {:
            v.forEach(b->{
              if(b.isGlobal()) b.setText("");
              else b.setText(b.getText()+";");
            });
            List<Node> c = new ArrayList<>();
            c.addAll(v);
            RESULT = c; :}
            | variable_assignment:v SEMICOLON
            {: v.setText(v.getText()+";");
            RESULT = new ArrayList<>(Arrays.asList(v)); :}
            | function_call_stmt:v SEMICOLON
            {: v.setText(v.getText()+";");
            RESULT = new ArrayList<>(Arrays.asList(v)); :}
            ;




if_stmt ::= IF:r LPAREN expression:e RPAREN THEN block:b
            {:RESULT = new IfStmt(new Location(rleft, rright), e, b, new ArrayList<>(), new ArrayList<>()); :}
            | IF:r LPAREN expression:e RPAREN THEN block:b else_if_stmts:elif
            {:RESULT = new IfStmt(new Location(rleft, rright), e, b, elif, new ArrayList<>()); :}
            | IF:r LPAREN expression:e RPAREN THEN block:b else_stmt:els
            {:RESULT = new IfStmt(new Location(rleft, rright), e, b, new ArrayList<>(), els); :}
            | IF:r LPAREN expression:e RPAREN THEN block:b else_if_stmts:elif else_stmt:els
            {:RESULT = new IfStmt(new Location(rleft, rright), e, b, elif, els); :}
            ;


else_if_stmts ::= else_if_stmt:b
                {:RESULT = new ArrayList<>(Arrays.asList(b)); :}
                | else_if_stmts:bs else_if_stmt:b
                {:
                bs.add(b);
                RESULT = bs;
                :}
                ;

else_if_stmt ::= ELSE:r IF LPAREN expression:e RPAREN THEN block:b
                {:RESULT = new IfStmt(new Location(rleft, rright), e, b); :}
                ;

else_stmt ::= ELSE block:b
            {:RESULT = b; :}
            ;

for_stmt ::= REPEAT:r LPAREN init_for:i RPAREN HUNTIL LPAREN expression:e RPAREN block:b
            {:RESULT = new ForStmt(new Location(rleft, rright), b, i, e, "++"); :}
            ;

init_for ::= INTEGER:i variable_id:id EQUAL:e expression:ex
            {:RESULT = new VariableDeclarator(new Location(ileft, iright), id, ex); :}
            | variable_id:id EQUAL:e expression:ex
            {:RESULT = new VariableDeclarator(new Location(idleft, idright), id, ex); :}
            ;

while_stmt ::= WHILE:w LPAREN expression:e RPAREN THENWHILE block:b
            {:RESULT = new WhileStmt(new Location(wleft, wright), b, e);:}
            ;






expression ::= conditional_expression:v
            {:RESULT = v; :}
            ;

conditional_expression ::= conditional_or_expression:v
                        {:RESULT = v; :}
                        ;

conditional_or_expression ::= conditional_and_expression:v
                            {:RESULT = v; :}
                            | conditional_or_expression:v1 OR:v2 conditional_and_expression:v3
                            {:RESULT = new BinaryExpression(new Location(v1left, v1right), Type.BOOLEAN, v1, v2, v3); :}
                            ;

conditional_and_expression ::= relational_expression:v
                        {:RESULT = v; :}
                        | conditional_and_expression:v1 AND:v2 relational_expression:v3
                        {:RESULT = new BinaryExpression(new Location(v1left, v1right), Type.BOOLEAN, v1, v2, v3); :}
                        ;

relational_expression ::= additive_expression:v
                        {:RESULT = v; :}
                        | relational_expression:v1 REL_OP:v2 additive_expression:v3
                        {:RESULT = new BinaryExpression(new Location(v1left, v1right), Type.BOOLEAN, v1, v2, v3); :}
                        ;

additive_expression ::= multiplicative_expression:v
                        {:RESULT = v; :}
                        | additive_expression:v1 PLUS:v2 multiplicative_expression:v3
                        {:RESULT = new BinaryExpression(new Location(v1left, v1right), null, v1, v2, v3); :}
                        | additive_expression:v1 MINUS:v2 multiplicative_expression:v3
                        {:RESULT = new BinaryExpression(new Location(v1left, v1right), null, v1, v2, v3); :}
                        ;

multiplicative_expression ::= unary_expression:v
                            {:RESULT = v; :}
                            | multiplicative_expression:v1 TIMES:v2 unary_expression:v3
                            {:RESULT = new BinaryExpression(new Location(v1left, v1right), null, v1, v2, v3); :}
                            | multiplicative_expression:v1 SLASH:v2 unary_expression:v3
                            {:RESULT = new BinaryExpression(new Location(v1left, v1right), null, v1, v2, v3); :}
                            ;

unary_expression ::= value_literal:v
                    {:RESULT = v; :}
                    | variable_id:v
                    {:RESULT = new UnaryExpression(new Location(vleft, vright), v.getText(), null, null, v); :}
                    | function_call_return:v
                    {:RESULT = new UnaryExpression(new Location(vleft, vright), v.getText(), null, null, v); :}
                    | MINUS unary_expression:v
                    {:
                    v.setOperator("-");
                    v.setText("-"+v.getText());
                    RESULT = v;
                    :}
                    | LPAREN expression:v RPAREN
                    {:
                    v.setText("("+v.getText()+")");
                    RESULT = (UnaryExpression) v;
                    :}
                    ;

value_literal ::= string_literal:v
                {:RESULT = new UnaryExpression(new Location(vleft, vright), "\""+v+"\"", Type.STRING, null, v);:}
                | NUMBER:v
                {:
                double num = Double.parseDouble(v.toString());
                Type tp;
                if(num % 1 != 0) tp = Type.DECIMAL;
                else tp = Type.INT;
                RESULT = new UnaryExpression(new Location(vleft, vright), v, tp, null, num);
                :}
                | char_literal:v
                {:RESULT = new UnaryExpression(new Location(vleft, vright), v, Type.CHAR, null, v);:}
                | TRUE:v
                {:RESULT = new UnaryExpression(new Location(vleft, vright), "true", Type.BOOLEAN, null, false);:}
                | FALSE:v
                {:RESULT = new UnaryExpression(new Location(vleft, vright), "false", Type.BOOLEAN, null, false);:}
                ;

string_literal ::= STRING_LITERAL:s {: RESULT = s.replaceAll("\"", "").replaceAll("\n", "\\n"); :}
                ;

char_literal ::= CHAR_LITERAL:c {: RESULT = c.replaceAll("'", ""); :}
                ;

simple_string ::= SIMPLE_STRING:s {: RESULT = s.replaceAll("'", "")/*.replaceAll("\n", "\\\\n")*/; :};

text ::= TEXT:t             {: RESULT = t; :}
        | IDENTIFIER:t      {: RESULT = t; :}
        | STRING_LITERAL:t  {: RESULT = t; :}
        | CHAR_LITERAL:t    {: RESULT = t; :}
        | SIMPLE_STRING:t   {: RESULT = t; :}
        | NUMBER:t          {: RESULT = t; :}
        | EQUAL:t           {: RESULT = t; :}
        | FUNCTION_ID:t     {: RESULT = t; :}
        | PLUS:t            {: RESULT = t; :}
        | MINUS:t           {: RESULT = t; :}
        | TIMES:t           {: RESULT = t; :}
        | SLASH:t           {: RESULT = t; :}
        | LPAREN:t          {: RESULT = t; :}
        | RPAREN:t          {: RESULT = t; :}
        | COLON:t           {: RESULT = t; :}
        | SEMICOLON:t       {: RESULT = t; :}
        | COMMA:t           {: RESULT = t; :}
        | VERTICAL_BAR:t    {: RESULT = t; :}
        | REL_OP:t          {: RESULT = t; :}
        | OR:t              {: RESULT = t; :}
        | AND:t             {: RESULT = t; :}
        | NOT:t             {: RESULT = t; :}
        | LBRACKET:t        {: RESULT = t; :}
        | RBRACKET:t        {: RESULT = t; :}
        | LBRACE:t          {: RESULT = t; :}
        | RBRACE:t          {: RESULT = t; :}
        ;

string_text ::= text:t
                {:
                RESULT = t;
                :}
                | string_text:s text:t
                {:
                RESULT = s + " " + t;
                :}
                ;